#!/usr/bin/env bash

__kitbash_trace=no
__kitbash_output_stream=/dev/null
__kitbash_dry_run=no
__kitbash_current_indent=0

declare -A __kitbash_dirty

__kitbash_usage() {
    echo "usage: $0 [-v] [-s] [-f] [-x] [-d <directory>] <dep name>"  >&2
    echo "  -d <directory> : search a custom directory"               >&2
    echo "  -s : use sudo if required"                                >&2
    echo "  -f : force operations"                                    >&2
    echo "  -x : trace mode (debug)"                                  >&2
    echo "  -y : dry-run, don't attempt to converge"                  >&2
    echo "  -v : verbose mode"                                        >&2
    exit 1
}

while getopts "vfxsyd:" opt; do
    case $opt in
        x)
            __kitbash_trace=yes
            ;;
        s)
        # TODO:
        # Hardcode the sudo path, since this is potentially a bit dicey
            __babashka_sudo="sudo"
            __kitbash_sudo="sudo"
            ;;
        f)
            __babashka_force="yes"
            __babushka_force="yes"
            __kitbash_force="yes"
            ;;
        d)
            # Set a custom directory to also source in
            __kitbash_directory=$(echo $OPTARG | xargs)
            ;;
        v)
            __kitbash_output_stream="/dev/stderr"
            ;;
        y)
            __kitbash_dry_run="yes"
            ;;
        \?)
            __kitbash_usage
            ;;
    esac
done

((shift_value = $OPTIND - 1))
shift $shift_value
unset OPTIND

if [ $__kitbash_trace = "yes" ]; then
    set -x
fi

kb_log() {
    printf "%*s"  "$__kitbash_current_indent" 1>&2
    printf "%s\n" "${*}" 1>&2
}

# here have some...meta
function fn_exists () {
  local function="${1}" ; shift
  declare -f "${function}" > /dev/null 2>&1
}

function __compat_shim () {
  local message="${1}"   ; shift
  local shim_name="${1}" ; shift
  local invokes="${1}"   ; shift
  fn_exists "${invokes}" && eval "function ${shim_name}() { kb_log \"${message}\" ; \"${invokes}\" \"\${@}\" ; }"
}

__compat_shim "called legacy __babashka_log" __babashka_log kb_log
__compat_shim "called legacy __kitbash_log" __kitbash_log kb_log

kb_fail() {
    printf 'ERROR: %s\n' "${*}" 1>&2
    exit 1
}
__compat_shim "called legacy __babashka_fail" __babashka_fail kb_fail
__compat_shim "called legacy __babashka_fail" __kitbash_fail kb_fail

unmeetable() {
    __kitbash_fail "$@"
}
function process() {
  local buf ; buf=""
  __process_is_met || {
    # Check if get_id is declared, so that we can log this in the
    # __kitbash_dirty array
    fn_exists get_target && {
      # get_target is a different take on get_id that requires more
      # from the invoker...but allows for on_change to not target a
      # specific meeting function. the intent is to reveal a more
      # basic event like "file:/foo/bar"
      buf="$(get_target)"
      [[ "${buf}" ]] && {
        # this is running in a subshell space, look at __kitbash_invoke
        __kitbash_dirty["${buf}"]="1"
        # tell the global kitbash what we touched, though
        printf '%s\n' "${buf}" 1>&12
      }
    }
    fn_exists get_id && {
      # The function we're in defined a get_id feature, so we can mark this
      # as a dirtied element so that later things can trigger on it
      # if they like.
      # *this* variant encodes the emitter's name, though.
      buf="$(get_id)"
      [[ "${buf}" ]] && {
        # this is running in a subshell space, look at __kitbash_invoke
        __kitbash_dirty["${FUNCNAME[1]}:${buf}"]="1"
        # tell the global kitbash what we touched, though
        printf '%s:%s\n' "${FUNCNAME[1]}" "${buf}" 1>&12
      }
    }
    if [[ "$__kitbash_dry_run" == "no" ]]; then
      __process_meet
      __process_is_met || kb_fail "dependency didn't converge"
    else
      kb_log '  `- dry run, skipping...'
    fi
  }
  # always attempt to close fd 12 so we can continue...
  exec 12>&-
  return 0
}

function __process_is_met() {
    kb_log '`- is met?'
    (set -e;is_met;) > $__kitbash_output_stream
    st=$?
    kb_log "  $st"
    return $st
}

function __process_meet() {
    kb_log "=> meet "
    meet > $__kitbash_output_stream
    st=$?
    kb_log "=> $st"
}

function on_change() {
  local trigger ; trigger="${1}" ; shift
  local runcmd ;  runcmd="${1}"  ; shift
  local st
  [[ "${runcmd}" ]] || kb_fail "on_change called against $1 missing second argument of what to do"
  # If a specific thing got dirtied, then we can run on that.
  # but it's ok if we didn't run at all.
  [[ -v __kitbash_dirty["${trigger}"] ]] || return 0
  "${runcmd}" "${@}"
  st=$?
  return $st
}

## Allow for functions to declare other functions as requirements
function requires() {
    __kitbash_invoke "$1"
}

### Need to spawn a subshell for this one.
## TODO: why?
function __requires_nested() {
    ( __kitbash_invoke "$1" ) || exit 1
}

# $1 - dep name to invoke
function __kitbash_invoke() {
    local kb_id
    (( __kitbash_current_indent = __kitbash_current_indent + 1 ))
    kb_log "-> $1"
    # before we run, we're gonna stomp on file descriptors, sorry
    exec 3>&1 4>&2
    # surprise! the function we invoke lives in a subshell...
    while IFS= read -r kb_id ; do
      [[ "${kb_id}" ]] && __kitbash_dirty["${kb_id}"]=1
    done < <(unset -f is_met ; unset -f meet ; unset -f get_id ; unset -f get_target ; eval "${1}" 12>&1 1>&3 2>&4)
    # be kind, rewind
    exec 3>&- 4>&-

    # that makes the return code 1 even if kitbash succeeds, because arithmetic
    # expressions behave differently than success/error of commands:
    # http://wiki.bash-hackers.org/syntax/arith_expr#truth
    #
    # so force it to succeed with || true, we don't want the increment/decrement
    # to alter the exit code anyway (will still return exit 1 if kitbash
    # failed to converge).
    (( __kitbash_current_indent = __kitbash_current_indent - 1 )) || true
}
function __kitbash_load_deps() {
    # Rename directories to be a bit more clear what they're for
    # Include a system-level Babashka repository for common packages and stuff
    for path in babashka/ babashka/dependencies/ /etc/babashka/dependencies /etc/babashka/helpers ; do
        if [ -d $path ]; then
            kb_log "loaded legacy babashka repository $path"
            __kitbash_load_deps_from_path "$path"
        fi
    done
    for path in kitbash/ kitbash/dependencies/ /etc/kitbash/dependencies /etc/kitbash/helpers ${__kitbash_directory:+$__kitbash_directory} ; do
        if [ -d $path ]; then
            __kitbash_load_deps_from_path "$path"
        fi
    done
}

# $1 - path to search over
# [$2] - pattern to match for deps
function __kitbash_find_deps_from_path() {
    local path="${1}"
    local ext="${2:-sh}"
    local recurse=yes
    local gs_state
    local files=()
    [[ -d "${path}" ]] && {
      case "${path}" in
        # Skip this, because it's likely a files directory and shouldn't be 
        # scanned
        */files) return ;;
        # Don't scan git directories, obviously
        */.git)  return ;;
      esac
    }
    # So we're looking for a special file, the "don't recurse" file, to keep
    # Kitbash from walking the whole tree to look for shell files to load.
    [[ -e "${path}/.kitbash_no_recurse" ]]  && recurse=no
    [[ -e "${path}/.babashka_no_recurse" ]] && { kb_log "using legacy .babashka_no_recurse marker at $1" ; recurse=no ; }

    # we're going to allow for finding 0 files, so we return success explicitly.
    if [[ "${recurse}" == "no" ]] ; then
      files=("${path}"/*".${ext}")
      [[ -f "${files[0]}" ]] && printf '%s\n' "${files[@]}"
      return 0
    else
      if [[ "${BASH_VERSINFO[0]}" -ge 4 ]] ; then
        gs_state="$(shopt globstar)"
        shopt -s globstar
        files=("${path}"/**/*".${ext}")
        case "${gs_state}" in
          *off) shopt -u globstar ;;
        esac
        [[ -f "${files[0]}" ]] && printf '%s\n' "${files[@]}"
        return 0
      else
        # Use -L to follow links
        find -L "${path}" -type f -iname "*.${ext}"
      fi
    fi
}

# $1 - path to load deps from
function __kitbash_load_deps_from_path() {
    for path in $(__kitbash_find_deps_from_path "$1"); do
        source $path
    done
}

__compat_shim "called legacy __babahska_load_deps_from_path" __babashka_load_deps_from_path __kitbash_load_deps_from_path

file_exists() {
    if [ "${1:0:7}" = "hdfs://" ]; then
        hadoop fs -test -e "$1"
    else
        test -f "$1"
    fi
}

dir_exists() {
    if [ "${1:0:7}" = "hdfs://" ]; then
        hadoop fs -test -d "$1"
    else
        test -f "$1"
    fi
}

file_mtime() {
    if [ "${1:0:7}" = "hdfs://" ]; then
        echo $(( $(hadoop fs -stat %Y "$1") / 1000 ))
    else
        stat -c %Y "$1"
    fi
}

file_is_newer() {
    target_mtime=$(file_mtime "$1")
    shift
    for f in "$@"; do
        mtime=$(file_mtime "$f")
        if [ $mtime -gt $target_mtime ]; then
            return 1
        fi
    done
    return 0
}

function __kitbash_main() {
    if [ $# -eq 1 ]; then
        __kitbash_invoke "$1"
    else
        __kitbash_usage
    fi
}

__kitbash_load_deps

__kitbash_main "$@"
