#!/bin/bash

__babashka_trace=no
# __babashka_output_stream=/dev/null
__babashka_dry_run=no


# Set the default log level
# Default log level is notice
KITBASH_LOG_LEVEL="${KITBASH_LOG_LEVEL:-4}"

declare -g KITBASH_MODELS_DIRECTORY_NAME="models.d"
declare -ag KITBASH_VARIABLE_SUFFIXES
KITBASH_VARIABLE_SUFFIXES=(
  sh
  bash
)

# Set up our various path arrays
declare -a KITBASH_LIBRARY_PATHS
KITBASH_LIBRARY_PATHS=(
  /etc/kitbash/lib
  # Deprecated but still used
  /etc/babashka/lib
  /etc/babashka/helpers
)

declare -ag KITBASH_VARIABLE_PATHS
KITBASH_VARIABLE_PATHS=(
  /etc/kitbash/variables
  # Deprecated but still used
  /etc/babashka/variables
)

declare -ag KITBASH_SECRETS_PATHS
KITBASH_SECRETS_PATHS=(
  /etc/kitbash/secrets
  # Deprecated but still used
  /etc/babashka/secrets
)

declare -a KITBASH_PROVISIONER_PATHS
# Defines the dependency paths. Always loaded after the main libraries.
KITBASH_PROVISIONER_PATHS=(
  ./kitbash
  ./.kitbash
  /etc/kitbash/provisioners
  /etc/kitbash/local
  # Deprecated but still useable
  ./babashka
  ./.babashka
  /etc/babashka/dependencies
  /etc/babashka/local
)

declare -a KITBASH_KIT_PATHS
KITBASH_KIT_PATHS=(
  # Vendored kitbash should be preferred to system kitbash for kits
  ./kitbash/kits
  ./.kitbash/kits
  /etc/kitbash/kits
  # Deprecated, supported for transitional reasons
  ./babashka/kits
  ./.babashka/kits
  /etc/babashka/kits
)

declare -a KITBASH_MODEL_PATHS
KITBASH_MODEL_PATHS=(
  ./kitbash/"$KITBASH_MODELS_DIRECTORY_NAME"
  ./.kitbash/"$KITBASH_MODELS_DIRECTORY_NAME"
  /etc/kitbash/"$KITBASH_MODELS_DIRECTORY_NAME"
  # Deprecated, supported for transitional reasons
  ./babashka/"$KITBASH_MODELS_DIRECTORY_NAME"
  ./.babashka/"$KITBASH_MODELS_DIRECTORY_NAME"
  /etc/babashka/"$KITBASH_MODELS_DIRECTORY_NAME"
)

declare -a KITBASH_LOCAL_PATHS
KITBASH_LOCAL_PATHS=(
  ./kitbash/local
  ./.kitbash/local
  /etc/kitbash/local
  # Supported for legacy reasons
  ./babashka/local
  ./.babashka/local
  /etc/babashka/local
)

declare -Ag KITBASH_KITS
declare -ag KITBASH_ORDERED_KITS
declare -ag KITBASH_ORDERED_MODELS
declare -Ag KITBASH_MODELS

# What model we're currently executing
declare -g KITBASH_CURRENT_MODEL
# Model inheritance tree
# We walk this in apply order
declare -ag KITBASH_MODEL_INHERITANCE

# kitbash.file path resolution tree
# generated via __kitbash_load_model, as it walks the model inheritance tree
declare -ag KITBASH_FILE_RESOLUTION_PATHS

# what kit we're currently resolving
declare -g KITBASH_CURRENT_KIT

# Set up our internal variables
__KITBASH_CURRENT_INDENT=0
declare -Ag __KITBASH_KIT_SEEN
declare -ag __KITBASH_KIT_TREE_STACK
declare -ag __KITBASH_MODEL_TREE_STACK
declare -a  __KITBASH_EXEC


declare -A __KITBASH_ENSURED
# Make system info a global value so that we can query it using the 
#   system.info commands

__babashka_usage() {
    echo "usage: babashka [-v] [-s] [-f] [-x] [-d <directory>] [command] <argument>" 
    echo "usage: babashka [-v] [-s] [-f] [-x] [-d <directory>] <dep name>" 
    echo "  -d <directory> : search a custom directory"                    
    # echo "  -l <level>: set log level"                                       
    echo "  -s : use sudo if required"                                     
    echo "  -f : force operations"                                         
    echo "  -x : bash trace mode (debug)"                                       
    echo "  -y : dry-run, don't attempt to converge"                       
    echo ""
    echo "commands:"                       
    echo "  apply   : Apply a model"                       
    echo "  kits    : List installed kits"                       
    echo "  models  : List configured models"                       
    # echo "  -v : verbose mode"                                              >&2
    exit 1
}

parse_main_args() {
  local opt OPTIND
  OPTIND=1
  while getopts "vfxsyd:" opt; do
      case $opt in
          x)
              __babashka_trace=yes
              ;;
          s)
          # TODO:
          # Hardcode the sudo path, since this is potentially a bit dicey
          # TODO:
          # Is this even a good idea? Like, I think we should make the converge
          #   either run _as_ root, or not be able to do sudo operations itself.
          #   None of this ... half-measure stuff.
              __babashka_sudo="sudo"
              ;;
          f)
              __babushka_force="yes"
              ;;
          d)
              # Set a custom directory to also source in
              # __babashka_directory="$(echo "$OPTARG" | xargs)"
              if [[ -d "$OPTARG" ]]; then
                KITBASH_PROVISIONER_PATHS+=( "$OPTARG" )
              fi
              ;;
          v)
              __babashka_output_stream="/dev/stderr"
              ;;
          y)
              __babashka_dry_run="yes"
              ;;
          \?)
              __babashka_usage
              ;;
      esac
  done
  
  ((shift_value = OPTIND - 1))
  shift $shift_value
  REMAINING_ARGS=("$@")
}

__babashka_log() {
  # emit apply "%*s%s\n" "$__babashka_current_indent" ""
  emit apply "$@"
  # (( indent = indent * 5))
  #   printf "%*s"  "$indent" 1>&2
  #   printf "%s\n" "$@" 1>&2
  # printf "%${indent}s\n" "-$@"
  # printf "%${indent}s\n" "-$@" | emit apply
}

__babashka_fail() {
    # echo ERROR: "$@" 1>&2
    emit error "$@"
    emit error "dependency didn't converge"
    exit 1
}

kitbash.fail() {
  __babashka_fail "$@"
}

__kitbash_error() {
  if declare -F "log.error" ; then
    log.error "$1"
  else
    echo "[ERROR]: $1"
  fi
  exit 1
}

unmeetable() {
    __babashka_fail "$@"
}

__incr() {
  (( __KITBASH_CURRENT_INDENT = __KITBASH_CURRENT_INDENT + 1 )) || true
}

__decr() {
  [[ "$__KITBASH_CURRENT_INDENT" == 0 ]] && return
  (( __KITBASH_CURRENT_INDENT = __KITBASH_CURRENT_INDENT - 1 )) || true
}

process() {
    # Allows recursive "process" calls to mask over other context values,
    # which is important during recursive `requires` calls, for instance.
    # Convergence functions that implement `get_id` will get to include extra
    # information as well.
    local KITBASH_CONTEXT
    KITBASH_CONTEXT="${FUNCNAME[1]}"
    local __id
    if declare -F get_id > /dev/null; then
      __id="$(get_id)"
      KITBASH_CONTEXT="${FUNCNAME[1]} $__id"
    fi
    emit header "$KITBASH_CONTEXT"
    __incr
    if ! process_is_met; then
      # Check if get_id is declared, so that we can log this in the 
      # __babashka_dirty array
      if [[ -n "$__id" ]]; then
        # The function we're in defined a get_id feature, so we can mark this
        # as a dirtied element so that later things can trigger on it
        # if they like.
        # This works because "process" is called at the end of the
        # convergence function, in order to trigger the "I should 
        # converge now" functionality.
        __KITBASH_ENSURED["${FUNCNAME[1]}:${__id}"]="1"
      fi
      if [[ "$__babashka_dry_run" == "no" ]]; then
        
        process_meet
        process_is_met || __babashka_fail "dependency didn't converge"
        declare -F finally > /dev/null 2>&1 && finally
      else
        __babashka_log '`- dry run, skipping...'
        # __babashka_log '  
      fi
    fi
    if declare -F finally > /dev/null 2>&1; then
      finally
    fi
    __decr
    # If get_id exists we want to unset it so that we don't get
    # odd behaviours across invocations where it's not yet implemented.
    local extensions=(get_id finally)
    for ext in "${extensions[@]}"; do
      if declare -F "$ext" > /dev/null 2>&1; then
        unset -f "$ext"
      fi
    done
}

process_is_met() {
    emit apply "is met?"
    __incr
    is_met 
    st="$?"
    if [[ "$st" -eq 0 ]]; then
      emit ok  "yes"
    else
      emit no  "no"
    fi
    __decr
    # printf "  $st\n"
    return "$st"
}

process_meet() {
  emit apply meet
    # prinf "=> meet "
  __incr
  meet
  st="$?"
  [[ "$st" -eq 0 ]] && emit ok met
  __decr
  return "$st"
    # TODO:
    # `meet` failing should cause an abort?
    # __babashka_log "=> $st"
}

on_change() {
  # If a specific thing got dirtied, then we can return true to that.
  [[ -v __babashka_dirty["$1"] ]]
}

## Allow for functions to declare other functions as requirements

requires() {
  __babashka_invoke "$1"
}

### Need to spawn a subshell for this one.

requires_nested() {
    ( __babashka_invoke "$1" ) || exit 1
}

# $1 - dep name to invoke
__babashka_invoke() {
    # (( __KITBASH_CURRENT_INDENT = __KITBASH_CURRENT_INDENT + 1 ))
    __incr
    # emit.indented "$__KITBASH_CURRENT_INDENT" apply "$1"
    
    # Is eval the right way to do this?
    # Hmm.
    log.debug "attempting to invoke $1"
    if declare -F "$1" > /dev/null; then
      log.debug "invoking $1"
      eval "$1"
    else
      log.debug "Function not defined: '$1'"
      __babashka_fail "Function \`$1\` does not exist."
    fi
    
    
    # that makes the return code 1 even if babashka succeeds, because arithmetic
    # expressions behave differently than success/error of commands:
    # http://wiki.bash-hackers.org/syntax/arith_expr#truth
    #
    # so force it to succeed with || true, we don't want the increment/decrement
    # to alter the exit code anyway (will still return exit 1 if babashka
    # failed to converge).
    __decr
    # (( __KITBASH_CURRENT_INDENT = __KITBASH_CURRENT_INDENT - 1 )) || true
}
__kitbash_load_libraries() {
  local path
  for path in "${KITBASH_LIBRARY_PATHS[@]}"; do
    if [[ -d "$path" ]]; then
      __babashka_load_deps_from_path "$path"
    fi
  done
}
__kitbash_load_provisioners() {
    # Rename directories to be a bit more clear what they're for
    # Include a system-level Babashka repository for common packages and stuff
    # Always load helpers first
    # Assumes that our main config directory is going to be /etc which may not
    #   actually be true, but is for my purposes right now, so that's what
    #   we're gonna get.
    # TODO:
    #  - Make this a default
    #  - Add a /etc/defaults/babashka that gets read in to provide these 
    #       variables instead of hardcoding them here
    local path
    for path in "${KITBASH_PROVISIONER_PATHS[@]}"; do
      if [[ -d "$path" ]]; then
        __babashka_load_deps_from_path "$path"
      fi
    done
    # for path in /etc/babashka/helpers ./babashka/ /etc/babashka/dependencies "${__babashka_directory:+$__babashka_directory}"; do
    #     if [ -d "$path" ]; then
    #         __babashka_load_deps_from_path "$path"
    #     fi
    # done
}

__kitbash_parse_json() {
  # name = "postgres"
  # description = "PostgreSQL Debian-alike module for Kitbash."
  # version = "1.0.0"
  # depends = ["pgdg"]
  # variables = [
  #   "POSTGRESQL_VERSION"
  # ]
  local path
  
  path="$1"
  if ! [[ -f "$path" ]]; then
    log.debug "No such path $path"
    return 1
  fi
  
  # Optional second argument, a variable to parse the TOML into
  if [[ -n "$2" ]]; then
    log.debug "Passed destination hash '$2'"
    declare -n PARSED_JSON="$2"
  else
    # overwrite whatever's in there, so that this is a "clean" parser
    log.debug "Using global PARSED_JSON"
    declare -Ag PARSED_JSON
  fi
  
  local key
  local name
  # output format is in the form of 
  # - keyname
  # there should always be a name value
  name=$(jq -r '.name' "$path")
  log.debug "Name is $name"
  if [[ -z "$name" ]]; then
    log.error "Missing 'name' key in $path"
    return 1
  fi
  local key_type
  local keys
  for key in $( jq -r 'keys | .[]' "$path" ); do
    key_type=$( jq -r ".$key | type" "$path")
    case "$key_type" in
      object)
        log.error "Unsupported key type object in $path: $key"
        continue
        ;;
      array)
        PARSED_JSON["${name}__${key}"]=$(jq -r ".$key | join(\",\")" "$path")
        ;;
      null)
        # do nothing
        log.debug "Null value for $key"
        ;;
      *)
        PARSED_JSON["${name}__${key}"]=$(jq -r ".$key" "$path")
        ;;
    esac
    log.debug "Setting ${name}__${key}"
    
    log.debug "Set as ${PARSED_JSON["${name}__${key}"]}"
  done
}

###

__kitbash_load_kit() {
  local kit
  kit="$1"
  if ! [[ -n "$kit" ]]; then
    log.error "Kit not defined?"
    return 1
  fi
  if contains __KITBASH_KIT_TREE_STACK "$kit"; then
    emit error "Kit already loaded (possible cycle?): $kit"
    return 1
  fi
  types.set.append __KITBASH_KIT_TREE_STACK "$kit"
  
  local path p
  for p in "${KITBASH_KIT_PATHS[@]}"; do
    log.debug "Searching path '$p' for kit '$kit'"
    if [[ -d "$p/$kit" ]]; then
      path="$p/$kit"
      log.debug "Found kit $kit at path: '$path'"
      break
    fi
  done
  if [[ -z "$path" ]]; then
    # Our string management stuff should exist now
    log.error "Could not find kit: '$kit'"
    exit 1
  fi
  local dependencies
  local dep
  if [[ -f "$path/kitbash.json" ]]; then
    __kitbash_parse_json "$path/kitbash.json" KITBASH_KITS
    # the KITBASH_KITS[$kit__] namespace should now be populated
    if [[ -v KITBASH_KITS["${kit}__depends"] ]]; then
      # Let's iterate over loading the kits
      IFS="," read -ra dependencies <<< "${KITBASH_KITS["${kit}__depends"]}"
      for dep in "${dependencies[@]}"; do
        log.debug "Loading $kit dependency $dep"
        __kitbash_load_kit "$dep"
        if ! [[ $? ]]; then
          log.error "Cycle detected: $kit -> $dep"
          exit 1
        fi
      done
    fi
    # Right, let's load it in then.
    # TODO: Extend this to support more complex loading and stuff.
    __babashka_load_deps_from_path "$path"
    types.set.append KITBASH_ORDERED_KITS "$kit"
    # should return this current kit
    array.pop __KITBASH_KIT_TREE_STACK
  else
    kitbash.fail "Missing $path/kitbash.json"
  fi
}

__kitbash_load_models() {
  local path
  local model
  for path in "${KITBASH_MODEL_PATHS[@]}"; do
    if [[ -d "$path" ]]; then
      shopt -s nullglob
      for model in "$path"/*.json; do
        __kitbash_load_model "$model"
      done
      shopt -u nullglob
    fi
  done
}

__kitbash_load_model() {
  
  local key name
  
  local _path model_path fn path
  local model
  model="$1"
  
  if contains __KITBASH_MODEL_TREE_STACK "$model"; then
    log.error "Model cycle detected: $model"
    return 1
  fi
  
  log.debug "Searching for model '$model'"
  for _path in "${KITBASH_MODEL_PATHS[@]}"; do
    log.debug "Checking model path $_path"
    # If this model path even exists
    if [[ -d "$_path" ]]; then
      log.debug "path exists: $_path"
      # Even if there's a $model.json, the path will always be the model
      # name, which is where the files/ directory will always live
      path="$_path/$model"
      # Do we have a bare name definition?
      if [[ -e "$_path/$model.json" ]]; then
        model_path="$_path/$model.json"
        log.debug "Found model definition: $model_path"
        break
      # Or is it in the model folder itself?
      elif [[ -e "$_path/$model/kitbash.json" ]]; then
        model_path="$_path/$model/kitbash.json"
        log.debug "Found model definition: $model_path"
        break
      fi
    fi
  done
  
  [[ -z "$model_path" ]] && kitbash.fail "Could not find model definition for $model."
  types.set.append __KITBASH_MODEL_TREE_STACK "$model"
  
  log.debug "model: $model"
  log.debug "model file: $model_path"
  name=$(jq -r '.name' "$model_path")
  if [[ -z "$name" ]]; then
    log.error "Bad model file: $model_path"
    exit 1
  fi
  
  __kitbash_parse_json "$model_path" KITBASH_MODELS
  
  # Add this models' files to the file path resolver, if it exists.
  [[ -e "$path"/files ]] && types.set.append KITBASH_FILE_RESOLUTION_PATHS "$path"
  
  types.set.append KITBASH_ORDERED_MODELS "$model"
  
  # Load inherited models
  
  if [[ -v KITBASH_MODELS["${name}__inherits"] ]]; then
    log.debug "Found model kits: ${KITBASH_MODELS["${name}__inherits"]}"
    local dependencies
    # These are all read in as CSV to make later parsing easier
    IFS="," read -ra dependencies <<< "${KITBASH_MODELS["${name}__inherits"]}"
    local dep
    for dep in "${dependencies[@]}"; do
      log.debug "Attempting to load inherited model '$dep'"
      __kitbash_load_model "$dep"
    done
    # We've loaded the inherited model tree, so we can pop ourselves from the
    # list of models in this particular segment of the DAG.
    array.pop __KITBASH_MODEL_TREE_STACK
  else
    log.debug "No inherited models found for $name"
  fi
  # Load our kits I guess?
  # Should this be in "kits" or "requires" or what? Hmm.
  
  if [[ -v KITBASH_MODELS["${name}__kits"] ]]; then
    log.debug "Found model kits: ${KITBASH_MODELS["${name}__kits"]}"
    local dependencies
    # These are all read in as CSV to make later parsing easier
    IFS="," read -ra dependencies <<< "${KITBASH_MODELS["${name}__kits"]}"
    local dep
    for dep in "${dependencies[@]}"; do
      log.debug "Attempting to load kit '$dep'"
      __kitbash_load_kit "$dep"
    done
  else
    log.debug "No kits found for $name"
  fi
  # Finally, parse in the model itself
  __babashka_load_deps_from_path "$path"
}

kitbash.apply_inherited() {
  local -a inherited_models
  local model
  model="$1"
  log.debug "Checking for inherited models for '$model'"
  
  types.set.append KITBASH_MODEL_INHERITANCE "$model"
  
  if [[ -v KITBASH_MODELS["${model}__inherits"] ]]; then
    log.debug "Found model inheritance: ${KITBASH_MODELS["${model}__inherits"]}"
    local dependencies
    # These are all read in as CSV to make later parsing easier
    IFS="," read -ra dependencies <<< "${KITBASH_MODELS["${model}__inherits"]}"
    local dep
    for dep in "${dependencies[@]}"; do
      log.debug "Attempting to apply model '$dep'"
      kitbash.apply "$dep"
      if ! [[ $? ]]; then
        return $?
      fi
    done
  else
    log.debug "No inherited models found for '$model'."
  fi
  return 0
}

kitbash.apply_kits() {
  # First, validate all the kits, before we try to run anything
  local -A kit_functions
  log.debug "Applying kits"
  # log.debug "$( types.array.reverse KITBASH_ORDERED_KITS )"
  for kit in $( types.array.reverse KITBASH_ORDERED_KITS ); do
    if [[ -v KITBASH_KITS["${kit}__entrypoint"] ]]; then
      if ! declare -F "${KITBASH_KITS["${kit}__entrypoint"]}" > /dev/null 2>&1; then
        kitbash.fail "${KITBASH_KITS["${kit}__entrypoint"]} declared but not defined."
      fi
      kit_functions+=( ["$kit"]="${KITBASH_KITS["${kit}__entrypoint"]}" )
    else
      # Use the default
      if ! declare -F "kit.$kit.apply" > /dev/null 2>&1; then
        kitbash.fail "Default entrypoint kit.$kit.apply not defined"
      fi
      kit_functions+=( ["$kit"]="kit.$kit.apply" )
    fi
  done
  # Then, run stuff
  for kit in "${!kit_functions[@]}"; do
    KITBASH_CURRENT_KIT="$kit"
    log.debug "Attempting to invoke kit '${kit_functions["$kit"]}'"
    __babashka_invoke "${kit_functions["$kit"]}"
  done
}

kitbash.apply() {
  local model entrypoint
  model="$1"
  
  if [[ -z "${KITBASH_MODELS["${model}__entrypoint"]}" ]]; then
    emit warn "Model entrypoint not defined: $model"
    emit warn "Attempting to use default model.$model.apply"
    if declare -f model."$model".apply > /dev/null 2>&1; then
      entrypoint=model."$model".apply
    else
      kitbash.fail "Entrypoint not defined and no default: $model"
    fi
  else
    entrypoint="${KITBASH_MODELS["${model}__entrypoint"]}"
  fi
  # Add ourself to the inheritance list
  types.set.append KITBASH_MODEL_INHERITANCE "$model"
  # Don't allow overwriting of the current model, since we want the model to
  # override its inherited models, if relevant.
  [[ -z "$KITBASH_CURRENT_MODEL" ]] && KITBASH_CURRENT_MODEL="$model"
  # First, we need to iterate through the kits that are to be applied as part
  # of this model, and apply them as well.
  # Models should only need to declare what kits they need, and not be
  # required to run them directly.
  __incr
  kitbash.apply_inherited "$model" || kitbash.fail "Failed to apply inherited models."
  # Remove ourself from the inheritance list
  types.set.pop KITBASH_MODEL_INHERITANCE "$model"
  # kitbash.apply_kits || kitbash.fail "Failed to apply kits."
  __decr
  
  log.debug "Attempting to invoke $entrypoint"
  __babashka_invoke "$entrypoint" || kitbash.fail
}

kitbash.ensure() {
  local provisioner identifier
  provisioner="$1"
  identifier="$2"
  log.debug "Checking for ensured $provisioner:$identifier"
  if [[ -v __KITBASH_ENSURED["$provisioner:$identifier"] ]]; then
    log.debug "Found"
    return 0
  fi
  log.debug "Not found"
  log.error "Could not find ensure for $provisioner:$identifier."
  return 1
}

# $1 - path to search over
# [$2] - pattern to match for deps
__babashka_find_deps_from_path() {
    # Use -L to follow links
    # So we're looking for a special file, the "don't recurse" file, to keep
    # Babashka from walking the whole tree to look for shell files to load.
    # We also want to skip any directories named "files", since that's the default
    # location for files being used by configuration management to live.
    if [[ "$(basename "$1")" == "files" ]] && [[ -d "$1" ]]; then 
        # Skip this, because it's likely a files directory and shouldn't be 
        # scanned
        return
    fi
    if [[ "$(basename "$1")" == ".git" ]] && [[ -d "$1" ]]; then 
        # Don't scan git directories, obviously
        return
    fi
    # If there's a no-recurse marker here, skip the directory.
    # This is so that we can set up our dependencies such that we have cross-
    #   platform-ish 
    if [ -e "${1}/.babashka_no_recurse" ]; then
        /usr/bin/find -L "$1" -maxdepth 1 -type f -iname "*.${2:-sh}" | sort
    else
        /usr/bin/find -L "$1" -type f -iname "*.${2:-sh}" | sort
    fi
}

# so we can log before the main logging system gets initialized
log.debug() {
  (( "${KITBASH_LOG_LEVEL:-0}" == 0 )) || return
  echo "$1" >&2
}

# $1 - path to load deps from
__babashka_load_deps_from_path() {
  for path in $(__babashka_find_deps_from_path "$1"); do
    log.debug "Loading dependencies from path: $path"
    # Because this is dynamic discovery, we don't care if shellcheck can't
    #   figure out what's being sourced.
    # shellcheck source=/dev/null
    . "$path"
  done
}

__babashka_main() {
    # if [ $# -eq 1 ]; then
    # Bash-specific version, but this is a Bash tool, so that doesn't matter
    #   overly much.
    # Why use a good argument parser when we can use a hacky argument
    # parser!
    
    parse_main_args "$@"
    
    if [ $__babashka_trace = "yes" ]; then
        set -x
    fi
    
    if (( "$#" >= 1 )); then
      local model
      case "$1" in
        apply)
          # TODO
          # Support more than one model being applied
          model="$2"
          __kitbash_load_model "$model"
          # Initialize the vars system
          kitbash.vars.init
          log.debug "Applying all kits"
          kitbash.apply_kits || kitbash.fail "Failed to apply kits."
          log.debug "Applying model '$model'"
          kitbash.apply "$model"
        ;;
        kits)
          # Show our kits
          for path in "${KITBASH_KIT_PATHS[@]}"; do
            echo "$path:"
            for p in "$path"/*.*; do
              if [[ -d "$path/$p" && "$p" != "." && "$p" != ".." ]]; then
                echo "  - $p"
              fi
            done
          done
        ;;
        models)
          # Show our models
          for path in "${KITBASH_MODEL_PATHS[@]}"; do
            echo "$path:"
            shopt -s nullglob
            for model in "$path"/*.json; do
              echo "  - $model"
            done
            shopt -u nullglob
          done
        ;;
        validate)
          # Validate a model
          # Lists out all variables that are listed in all the kits, and
          # whether or not they can be found via info.var
          # TODO
          # - Fix this, this is. just. bad code.
          model="$2"
          log.debug "Validate $model"
          __kitbash_load_model "$model"
          KITBASH_CURRENT_MODEL="$model"
          # Run init
          kitbash.vars.init
          local m var v
          for m in "${KITBASH_ORDERED_MODELS[@]}"; do
            emit header $(str.color bold underline -- "Model: $m")
            #
            __incr
            #
            log.debug "Examining $m"
            emit header $(str.color underline -- "Variables:")
            if ! kitbash.model.has_key "$m" variables; then
              emit info "No variables..."
            else
              __incr
              for var in $(kitbash.model.variables "$m"); do
                v=$(info.var "$var" missing)
                if [[ "$v" == "missing" ]]; then
                  emit error $(str.color bold bg-red -- "$var")
                else
                  emit ok "$var: $v"
                fi
              done
              __decr
            fi
            
            # List out secrets next
            #
            emit header $(str.color underline -- "Secrets:")
            #
            __incr
            if ! kitbash.model.has_key "$m" secrets; then
              emit info "No secrets..."
            else
              for var in $(kitbash.model "$m" secrets); do
                if ! v=$(info.var.secret "$var"); then
                  emit error $(str.color bold bg-red -- "$var")
                else
                  emit ok "$var:" $(str.color bold bg-white black -- "[REDACTED]")
                fi
              done
            fi
            __decr
            
            emit header $(str.color underline -- "Kits:")
            __incr
            if ! kitbash.model.has_key "$m" kits; then
              emit info "No kits..."
            else
              for kit in $(kitbash.model "$m" kits); do
                emit header $(str.color underline -- "$kit")
                __incr
                if ! kitbash.kit.has_key "$kit" variables; then
                  emit info "No variables..."
                else
                  __incr
                  for var in $(kitbash.kit "$kit" variables); do
                    log.debug "$var"
                    v=$(info.var "$var" missing)
                    if [[ "$v" == "missing" ]]; then
                      emit error $(str.color bold bg-red -- "$var")
                    else
                      emit ok "$var: $v"
                    fi
                  done
                  __decr
                fi
                # __decr
                emit header $(str.color italic underline -- "secrets")
                __incr
                for var in $(kitbash.kit "$kit" secrets); do
                  if ! v=$(info.var.secret "$var"); then
                    emit error $(str.color bold bg-red -- "$var")
                  else
                    emit ok "$var:" $(str.color bold bg-white black -- "[REDACTED]")
                  fi
                done
                __decr
                __decr
              done
              __decr
            fi
            __decr
            __decr
          done
          # Then lists out all the secrets, and whether or not they can be
          # found.
          ;;
        *)
          # Original path, so that we don't break prior functionality
          kitbash.vars.init
          __babashka_invoke "$1"
          ;;
      esac
    else
      __babashka_usage
    fi
}

# Populate our system information array before we load deps, since
#   we expect the deps to be able to make use of those functions to determine
#   if they should load or not.


# load our dependency tree, including our helpers
__kitbash_load_libraries
__kitbash_load_provisioners

# Converge. CONVERGE. COMPLY.

if [[ ${BASH_SOURCE[0]} == "$0" ]]; then
  __babashka_main "$@"
fi