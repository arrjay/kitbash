#!/bin/bash

__babashka_trace=no
__babashka_output_stream=/dev/null
__babashka_dry_run=no

# set -x
# PS4='+$(date "+%F %T") ${FUNCNAME[0]}() $BASH_SOURCE:${BASH_LINENO[0]}+ '
# set -o xtrace

declare -A __babashka_dirty
# Make system info a global value so that we can query it using the 
#   system::info commands

__babashka_usage() {
    echo "usage: babashka [-v] [-s] [-f] [-x] [-d <directory>] <dep name>"  >&2
    echo "  -d <directory> : search a custom directory"                     >&2
    echo "  -s : use sudo if required"                                      >&2
    echo "  -f : force operations"                                          >&2
    echo "  -x : trace mode (debug)"                                        >&2
    echo "  -y : dry-run, don't attempt to converge"                        >&2
    echo "  -v : verbose mode"                                              >&2
    exit 1
}

while getopts "vfxsyd:" opt; do
    case $opt in
        x)
            __babashka_trace=yes
            ;;
        s)
        # TODO:
        # Hardcode the sudo path, since this is potentially a bit dicey
        # TODO:
        # Is this even a good idea? Like, I think we should make the converge
        #   either run _as_ root, or not be able to do sudo operations itself.
        #   None of this ... half-measure stuff.
            __babashka_sudo="sudo"
            ;;
        f)
            __babushka_force="yes"
            ;;
        d)
            # Set a custom directory to also source in
            __babashka_directory="$(echo "$OPTARG" | xargs)"
            ;;
        v)
            __babashka_output_stream="/dev/stderr"
            ;;
        y)
            __babashka_dry_run="yes"
            ;;
        \?)
            __babashka_usage
            ;;
    esac
done

((shift_value = OPTIND - 1))
shift $shift_value
unset OPTIND
# echo "Remanant: $@"
if [ $__babashka_trace = "yes" ]; then
    set -x
fi

__babashka_log() {
    printf "%*s"  "$__babashka_current_indent" 1>&2
    printf "%s\n" "$@" 1>&2
}

__babashka_fail() {
    echo ERROR: "$@" 1>&2
    exit 1
}

unmeetable() {
    __babashka_fail "$@"
}

process() {
    # show call stack
    if ! process_is_met; then
        # Check if get_id is declared, so that we can log this in the 
        # __babashka_dirty array
        if type get_id &> /dev/null; then
            # The function we're in defined a get_id feature, so we can mark this
            # as a dirtied element so that later things can trigger on it
            # if they like.
            local __id
            __id="$(get_id)"
            __babashka_dirty["${FUNCNAME[1]}:${__id}"]="1"
        fi
        if [ "$__babashka_dry_run" = "no" ]; then
            process_meet
            process_is_met || __babashka_fail "dependency didn't converge"
        else
            __babashka_log '  `- dry run, skipping...'
        fi
    fi
    # If get_id exists we want to unset it so that we don't get
    # odd behaviours across invocations where it's not yet implemented.
    if type get_id &> /dev/null; then
        unset -f get_id
    fi
}

process_is_met() {
    __babashka_log '`- is met?'
    is_met > $__babashka_output_stream
    st=$?
    __babashka_log "  $st"
    return $st
}

process_meet() {
    __babashka_log "=> meet "
    meet > $__babashka_output_stream
    st=$?
    # TODO:
    # `meet` failing should cause an abort?
    __babashka_log "=> $st"
}

on_change() {
  # If a specific thing got dirtied, then we can return true to that.
  [[ -v __babashka_dirty["$1"] ]]
}

## Allow for functions to declare other functions as requirements

requires() {
  __babashka_invoke "$1"
}

### Need to spawn a subshell for this one.

requires_nested() {
    ( __babashka_invoke "$1" ) || exit 1
}

# $1 - dep name to invoke
__babashka_invoke() {
    (( __babashka_current_indent = __babashka_current_indent + 1 ))
    __babashka_log "-> $1"
    
    # Is eval the right way to do this?
    # Hmm.
    if declare -F "$1" > /dev/null; then
      eval "$1"
    else
      __babashka_fail "Function \`$1\` does not exist."
    fi
    
    
    # that makes the return code 1 even if babashka succeeds, because arithmetic
    # expressions behave differently than success/error of commands:
    # http://wiki.bash-hackers.org/syntax/arith_expr#truth
    #
    # so force it to succeed with || true, we don't want the increment/decrement
    # to alter the exit code anyway (will still return exit 1 if babashka
    # failed to converge).
    (( __babashka_current_indent = __babashka_current_indent - 1 )) || true
}
__babashka_load_deps() {
    # Rename directories to be a bit more clear what they're for
    # Include a system-level Babashka repository for common packages and stuff
    # Always load helpers first
    # Assumes that our main config directory is going to be /etc which may not
    #   actually be true, but is for my purposes right now, so that's what
    #   we're gonna get.
    # TODO:
    #  - Make this a default
    #  - Add a /etc/defaults/babashka that gets read in to provide these 
    #       variables instead of hardcoding them here
    for path in /etc/babashka/helpers ./babashka/ /etc/babashka/dependencies "${__babashka_directory:+$__babashka_directory}"; do
        if [ -d "$path" ]; then
            __babashka_load_deps_from_path "$path"
        fi
    done
}

# $1 - path to search over
# [$2] - pattern to match for deps
__babashka_find_deps_from_path() {
    # Use -L to follow links
    # So we're looking for a special file, the "don't recurse" file, to keep
    # Babashka from walking the whole tree to look for shell files to load.
    # We also want to skip any directories named "files", since that's the default
    # location for files being used by configuration management to live.
    if [[ "$(basename "$1")" == "files" ]] && [[ -d "$1" ]]; then 
        # Skip this, because it's likely a files directory and shouldn't be 
        # scanned
        return
    fi
    if [[ "$(basename "$1")" == ".git" ]] && [[ -d "$1" ]]; then 
        # Don't scan git directories, obviously
        return
    fi
    # If there's a no-recurse marker here, skip the directory.
    # This is so that we can set up our dependencies such that we have cross-
    #   platform-ish 
    if [ -e "${1}/.babashka_no_recurse" ]; then
        find -L "$1" -maxdepth 1 -type f -iname "*.${2:-sh}" 
    else
        find -L "$1" -type f -iname "*.${2:-sh}"
    fi
}

# $1 - path to load deps from
__babashka_load_deps_from_path() {
    for path in $(__babashka_find_deps_from_path "$1"); do
        # Because this is dynamic discovery, we don't care if shellcheck can't
        #   figure out what's being sourced.
        # shellcheck source=/dev/null
        source "$path"
    done
}

__babashka_main() {
    # if [ $# -eq 1 ]; then
    # Bash-specific version, but this is a Bash tool, so that doesn't matter
    #   overly much.
    if (( $# == 1 )); then
        __babashka_invoke "$1"
    else
        __babashka_usage
    fi
}

# Populate our system information array before we load deps, since
#   we expect the deps to be able to make use of those functions to determine
#   if they should load or not.


# load our dependency tree, including our helpers
__babashka_load_deps

# Converge. CONVERGE. COMPLY.
__babashka_main "$@"