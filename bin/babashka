#!/usr/bin/env bash

__kitbash_trace=no
__kitbash_output_stream=/dev/null
__kitbash_dry_run=no
__kitbash_current_indent=0

declare -A __kitbash_dirty

__kitbash_usage() {
    echo "usage: $0 [-v] [-s] [-f] [-x] [-d <directory>] <dep name>"  >&2
    echo "  -d <directory> : search a custom directory"               >&2
    echo "  -s : use sudo if required"                                >&2
    echo "  -f : force operations"                                    >&2
    echo "  -x : trace mode (debug)"                                  >&2
    echo "  -y : dry-run, don't attempt to converge"                  >&2
    echo "  -v : verbose mode"                                        >&2
    exit 1
}

while getopts "vfxsyd:" opt; do
    case $opt in
        x)
            __kitbash_trace=yes
            ;;
        s)
        # TODO:
        # Hardcode the sudo path, since this is potentially a bit dicey
            __babashka_sudo="sudo"
            __kitbash_sudo="sudo"
            ;;
        f)
            __babashka_force="yes"
            __babushka_force="yes"
            __kitbash_force="yes"
            ;;
        d)
            # Set a custom directory to also source in
            __kitbash_directory=$(echo $OPTARG | xargs)
            ;;
        v)
            __kitbash_output_stream="/dev/stderr"
            ;;
        y)
            __kitbash_dry_run="yes"
            ;;
        \?)
            __kitbash_usage
            ;;
    esac
done

((shift_value = $OPTIND - 1))
shift $shift_value
unset OPTIND

if [ $__kitbash_trace = "yes" ]; then
    set -x
fi

__kitbash_log() {
    printf "%*s"  "$__kitbash_current_indent" 1>&2
    printf "%s\n" "$@" 1>&2
}
__babashka_log() {
    __kitbash_log "called legacy __babashka_log"
    __kitbash_log "$@"
}

__kitbash_fail() {
    echo ERROR: "$@" 1>&2
    exit 1
}
__babashka_fail() {
    __kitbash_log  "called legacy __babashka_fail"
    __kitbash_fail "$@"
}

unmeetable() {
    __kitbash_fail "$@"
}
function process() {
    if ! process_is_met; then
        # Check if get_id is declared, so that we can log this in the 
        # __kitbash_dirty array
        if type get_id &> /dev/null; then
            # The function we're in defined a get_id feature, so we can mark this
            # as a dirtied element so that later things can trigger on it
            # if they like.
            local __id=$(get_id)
            __kitbash_dirty["${FUNCNAME[1]}:${__id}"]="1"
        fi
        if [ "$__kitbash_dry_run" = "no" ]; then
            process_meet
            process_is_met || __kitbash_fail "dependency didn't converge"
        else
            __kitbash_log '  `- dry run, skipping...'
        fi
    fi
    # If get_id exists we want to unset it so that we don't get
    # odd behaviours across invocations where it's not yet implemented.
    if type get_id &> /dev/null; then
        unset -f get_id
    fi
}

function process_is_met() {
    __kitbash_log '`- is met?'
    is_met > $__kitbash_output_stream
    st=$?
    __kitbash_log "  $st"
    return $st
}

function process_meet() {
    __kitbash_log "=> meet "
    meet > $__kitbash_output_stream
    st=$?
    __kitbash_log "=> $st"
}

function on_change() {
    # If a specific thing got dirtied, then we can return true to that.
    [[ -v __kitbash_dirty["$1"] ]]
}

## Allow for functions to declare other functions as requirements

function requires() {
    __kitbash_invoke "$1"
}

### Need to spawn a subshell for this one.

function requires_nested() {
    ( __kitbash_invoke "$1" ) || exit 1
}

# $1 - dep name to invoke
function __kitbash_invoke() {
    (( __kitbash_current_indent = __kitbash_current_indent + 1 ))
    __kitbash_log "-> $1"
    eval "$1"

    # that makes the return code 1 even if kitbash succeeds, because arithmetic
    # expressions behave differently than success/error of commands:
    # http://wiki.bash-hackers.org/syntax/arith_expr#truth
    #
    # so force it to succeed with || true, we don't want the increment/decrement
    # to alter the exit code anyway (will still return exit 1 if kitbash
    # failed to converge).
    (( __kitbash_current_indent = __kitbash_current_indent - 1 )) || true
}
function __kitbash_load_deps() {
    # Rename directories to be a bit more clear what they're for
    # Include a system-level Babashka repository for common packages and stuff
    for path in babashka/ babashka/dependencies/ /etc/babashka/dependencies /etc/babashka/helpers ; do
        if [ -d $path ]; then
            __kitbash_log "loaded legacy babashka repository $path"
            __kitbash_load_deps_from_path "$path"
        fi
    done
    for path in kitbash/ kitbash/dependencies/ /etc/kitbash/dependencies /etc/kitbash/helpers ${__kitbash_directory:+$__kitbash_directory} ; do
        if [ -d $path ]; then
            __kitbash_load_deps_from_path "$path"
        fi
    done
}

# $1 - path to search over
# [$2] - pattern to match for deps
function __kitbash_find_deps_from_path() {
    local path="${1}"
    local ext="${2:-sh}"
    local recurse=yes
    local gs_state
    [[ -d "${path}" ]] && {
      case "${path}" in
        # Skip this, because it's likely a files directory and shouldn't be 
        # scanned
        */files) return ;;
        # Don't scan git directories, obviously
        */.git)  return ;;
      esac
    }
    # So we're looking for a special file, the "don't recurse" file, to keep
    # Kitbash from walking the whole tree to look for shell files to load.
    [[ -e "${path}/.kitbash_no_recurse" ]]  && recurse=no
    [[ -e "${path}/.babashka_no_recurse" ]] && { __kitbash_log "using legacy .babashka_no_recurse marker at $1" ; recurse=no ; }

    if [[ "${recurse}" == "no" ]] ; then
      printf '%s\n' "${path}"/*".${ext}"
    else
      if [[ "${BASH_VERSINFO[0]}" -ge 4 ]] ; then
        gs_state="$(shopt globstar)"
        shopt -s globstar
        printf '%s\n' "${path}"/**/*".${ext}"
        case "${gs_state}" in
          *off) shopt -u globstar ;;
        esac
      else
        # Use -L to follow links
        find -L "${path}" -type f -iname "*.${ext}"
      fi
    fi
}

# $1 - path to load deps from
function __kitbash_load_deps_from_path() {
    for path in $(__kitbash_find_deps_from_path "$1"); do
        source $path
    done
}
function __babashka_load_deps_from_path() {
    __kitbash_log "using legacy __babashka_load_deps_from_path against $1"
    __kitbash_load_deps_from_path "$1"
}
file_exists() {
    if [ "${1:0:7}" = "hdfs://" ]; then
        hadoop fs -test -e "$1"
    else
        test -f "$1"
    fi
}

dir_exists() {
    if [ "${1:0:7}" = "hdfs://" ]; then
        hadoop fs -test -d "$1"
    else
        test -f "$1"
    fi
}

file_mtime() {
    if [ "${1:0:7}" = "hdfs://" ]; then
        echo $(( $(hadoop fs -stat %Y "$1") / 1000 ))
    else
        stat -c %Y "$1"
    fi
}

file_is_newer() {
    target_mtime=$(file_mtime "$1")
    shift
    for f in "$@"; do
        mtime=$(file_mtime "$f")
        if [ $mtime -gt $target_mtime ]; then
            return 1
        fi
    done
    return 0
}

function __kitbash_main() {
    if [ $# -eq 1 ]; then
        __kitbash_invoke "$1"
    else
        __kitbash_usage
    fi
}

__kitbash_load_deps

__kitbash_main "$@"
